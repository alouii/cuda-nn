"""Plot kernel timing summaries from the CSV generated by the training run.

Features:
- Command-line args for input/output paths and options
- Computes mean, median and std and shows error bars
- Saves both PNG and SVG outputs and a summary CSV
- Annotates bars with mean values
"""

from pathlib import Path
import argparse
import sys
import pandas as pd
import matplotlib.pyplot as plt

# seaborn is optional; fall back to matplotlib style if unavailable
try:
	import seaborn as sns
	_SEABORN = True
except Exception:
	sns = None
	_SEABORN = False


def summarize_and_plot(csv_path: Path, out_dir: Path, show: bool = True, top_n=None):
	if not csv_path.exists():
		raise FileNotFoundError(f"CSV not found: {csv_path}")

	df = pd.read_csv(csv_path, comment='#')
	if 'Epoch' in df.columns:
		df = df.set_index('Epoch')

	# numeric columns only
	df = df.select_dtypes(include='number')
	if df.empty:
		raise ValueError("No numeric columns found in CSV")

	# summary stats
	stats = pd.DataFrame({
		'mean': df.mean(),
		'median': df.median(),
		'std': df.std()
	})

	if top_n is not None:
		stats = stats.sort_values('mean', ascending=False).head(top_n)

	out_dir.mkdir(parents=True, exist_ok=True)
	summary_csv = out_dir / 'kernel_times_summary.csv'
	stats.to_csv(summary_csv)

	# If CPU baseline columns are present (prefixed with 'cpu_'), produce a side-by-side GPU vs CPU plot
	cpu_cols = [c for c in stats.index if c.startswith('cpu_')]
	if cpu_cols:
		# derive kernel base names
		base_names = sorted({c for c in (c[len('cpu_'):] for c in cpu_cols)} | {c for c in stats.index if not c.startswith('cpu_')})
		# build paired DataFrame
		paired = []
		for name in base_names:
			gpu_mean = stats.loc[name, 'mean'] if name in stats.index else float('nan')
			gpu_std = stats.loc[name, 'std'] if name in stats.index else float('nan')
			cpu_name = f'cpu_{name}'
			cpu_mean = stats.loc[cpu_name, 'mean'] if cpu_name in stats.index else float('nan')
			cpu_std = stats.loc[cpu_name, 'std'] if cpu_name in stats.index else float('nan')
			paired.append((name, gpu_mean, gpu_std, cpu_mean, cpu_std))
		paired_df = pd.DataFrame(paired, columns=['kernel', 'gpu_mean', 'gpu_std', 'cpu_mean', 'cpu_std']).set_index('kernel')
		# plot grouped bars
		plt.figure(figsize=(max(8, 0.6*len(paired_df)), 6))
		x = range(len(paired_df))
		width = 0.35
		plt.bar([i - width/2 for i in x], paired_df['gpu_mean'], width, yerr=paired_df['gpu_std'], label='GPU', capsize=5)
		plt.bar([i + width/2 for i in x], paired_df['cpu_mean'], width, yerr=paired_df['cpu_std'], label='CPU', capsize=5)
		plt.xticks(x, paired_df.index, rotation=45, ha='right')
		plt.ylabel('Time (ms)')
		plt.title('GPU vs CPU Kernel Times')
		plt.legend()
		plt.tight_layout()
		out_gpu_cpu = out_dir / 'kernel_times_gpu_vs_cpu.png'
		plt.savefig(out_gpu_cpu)
		plt.close()

		# speedup plot
		paired_df['speedup'] = paired_df['cpu_mean'] / paired_df['gpu_mean']
		plt.figure(figsize=(max(8, 0.6*len(paired_df)), 4))
		plt.bar(paired_df.index, paired_df['speedup'], color='tab:green')
		plt.ylabel('Speedup (CPU / GPU)')
		plt.title('CPU / GPU speedup per kernel (higher is faster)')
		plt.xticks(rotation=45, ha='right')
		plt.tight_layout()
		out_speedup = out_dir / 'kernel_times_speedup.png'
		plt.savefig(out_speedup)
		plt.close()

	if _SEABORN:
		sns.set(style='whitegrid')
	else:
		plt.style.use('seaborn-whitegrid')
	plt.figure(figsize=(12, 6))
	ax = plt.gca()
	bars = ax.bar(stats.index, stats['mean'], yerr=stats['std'], color='tab:blue', alpha=0.85, capsize=5)
	ax.set_ylabel('Time (ms)')
	ax.set_title('Average Kernel Execution Time (with std)')
	plt.xticks(rotation=45, ha='right')

	# annotate bars with mean
	for bar, val in zip(bars, stats['mean']):
		h = bar.get_height()
		ax.annotate(f"{val:.2f}", xy=(bar.get_x() + bar.get_width() / 2, h), xytext=(0, 4),
					textcoords='offset points', ha='center', va='bottom', fontsize=8)

	plt.tight_layout()

	out_png = out_dir / 'kernel_times.png'
	out_svg = out_dir / 'kernel_times.svg'
	plt.savefig(out_png)
	plt.savefig(out_svg)

	if show:
		plt.show()
	else:
		plt.close()

	# include the GPU vs CPU files in the return when produced
	if cpu_cols:
		return summary_csv, out_png, out_svg, out_gpu_cpu, out_speedup

	return summary_csv, out_png, out_svg


def parse_args(argv=None):
	DEFAULT_CSV = Path(__file__).resolve().parent.parent / 'kernel_times.csv'
	DEFAULT_PLOTS = Path(__file__).resolve().parent.parent / 'plots'

	p = argparse.ArgumentParser(description='Plot kernel timing CSV produced by cuda_nn')
	p.add_argument('csv', nargs='?', default=str(DEFAULT_CSV), help='Path to kernel_times.csv')
	p.add_argument('-o', '--out', default=str(DEFAULT_PLOTS), help='Output directory for plots and summaries')
	p.add_argument('--no-show', dest='show', action='store_false', help="Don't show the interactive plot")
	p.add_argument('--top', type=int, default=None, help='Limit to top N kernels by mean time')
	return p.parse_args([] if argv is None else argv)


def main(argv=None):
	args = parse_args([] if argv is None else argv)
	csv_path = Path(args.csv)
	out_dir = Path(args.out)
	try:
		res = summarize_and_plot(csv_path, out_dir, show=args.show, top_n=args.top)
		# res is either (summary, png, svg) or (summary, png, svg, gpu_vs_cpu, speedup)
		summary_csv, out_png, out_svg, *rest = res
		print(f"Saved summary to: {summary_csv}")
		print(f"Saved plots: {out_png}, {out_svg}")
		if rest:
			print(f"Saved GPU vs CPU plot: {rest[0]}")
			print(f"Saved speedup plot: {rest[1]}")
	except Exception as e:
		print(f"Error: {e}", file=sys.stderr)
		return 2
	return 0


if __name__ == '__main__':
	raise SystemExit(main())
